# asyncio-client-sever
TCP server and client

Протокол взаимодействия
Клиент и сервер взаимодействуют между собой по простому текстовому протоколу через TCP сокеты. Текстовый протокол имеет главное преимущество – наглядность, можно просматривать диалог взаимодействия клиентской и серверной стороны без использования дополнительных инструментов.

Общий формат запросов и ответов.
Протокол поддерживает два вида запросов к серверу со стороны клиента:

- отправка данных для сохранения их на сервере

- получения сохраненных данных

Общий формат запроса клиента:  
<команда> <данные запроса><\n>

 <команда> - команда сервера (команда может принимать одно из двух значений: put — сохранить данные на сервере, get — вернуть сохраненные данные с сервера),

- <данные запроса> - данные запроса (их формат мы подробно разберем ниже в примере),

- <\n> - символ переноса строки.

Обратим ваше внимание на пробел между командой и данными запроса и его отсутствием между данными и символом перевода на новую строку.

Общий формат ответов сервера:  
<статус ответа><\n><данные ответа><\n\n>

- <статус ответа> - статус выполнения команды, допустимы два варианта: «ok» - команда успешно выполнена на сервере и «error» - выполнение команды завершилось ошибкой

- <данные ответа> - не обязательное поле (формат ответа и случаи его отсутствия будут рассмотрены в примере ниже)

- <\n\n> - два символа переноса строки.

Обратите внимание, что статус ответа и данные ответа разделены символом перевода строки <\n>.

Пример взаимодействия сервера и клиента.

Для наглядности рассмотрим протокол взаимодействия между клиентом и сервером на конкретном примере. В примере мы будем, собирать метрики с данными о работе операционной системы: cpu (загрузка процессора), usage (потребление памяти), disk_usage (потребление места на жестком диске), network_usage (статистика сетевых интерфейсов). Такие данные могут понадобится для контроля загрузки серверов и прогноза по расширению парка железа компании - проще говоря для мониторинга.

Какие данные мы будем сохранять?

Для каждой метрики (<key>) мы будем хранить данные о ее значениях (<value>) и времени, когда производилось измерение (<timestamp>) . Поскольку, в реальной жизни серверов может быть несколько, необходимо различать данные полученные от разных серверов (в нашем примере имеются в наличии два сервера palm и eardrum). Договоримся об именовании <key>, в примере мы будем определять их по правилу: 

<название сервера>.<название метрики><название сервера>.<название метрики>

Запросы клиента.

Рассмотрим пример отправки на сервер данных для сохранения. Пусть у нас имеются данные измерений - загрузка процессора «cpu» на сервере "palm" во время 1150864247 была равна 23.7 процента. Строка запроса в этом случае будет иметь вид:
  
  put palm.cpu 23.7 1150864247\n

В запросе на сохранение мы можем передать данные только об одном измерении.

Чтобы получить с сервера данные, сохраненные по ключу «palm.cpu», необходимо в данных запроса просто передать имя ключа:

get palm.cpu\n

Для случая, когда необходимо получить все хранимые на сервере данные, в качестве ключа используется символ звездочки «*». Пример строки запроса:  

get *\n

Ответы сервера.

Допустим, что на сервере хранятся данные: 

key          | value | timestamp  
-----------------------------------

"palm.cpu"    |  2.0  | 1150864247

"palm.cpu"    |  0.5  | 1150864248

"eardrum.cpu" |  3.0  | 1150864250

Тогда в ответ на запрос о получении данных по ключу "palm.cpu" сервер отправит строку:  

ok\npalm.cpu 2.0 1150864247\npalm.cpu 0.5 1150864248\n\n

Данные ответа содержат данные о каждой сохраненной записи с ключом "palm.cpu" (метрика, значение, временная метка разделенные пробелом), которые разделены символом перевода строки «\n».

Строка ответа сервера на запрос о получении всех хранящихся на сервере данных (в качестве ключа передано «*») в нашем случае будет таким:

ok\npalm.cpu 2.0 1150864247\npalm.cpu 0.5 1150864248\neardrum.cpu 3.0 1150864250\n\n

В случаях:

- когда в запросе на получение данных передан не существующий ключ

- успешного выполнения команды сохранения данных put

сервер отправляет клиенту строку со статусом «оk» и пустым полем с данными ответа:

ok\n\n

Если в параметре запроса переданы не валидные данные (например: нарушен формат запроса, ошибочная команда или значения value и timestamp не могут быть приведены к необходимому типу данных) сервер отправляет строку со статусом ответа «error» и данными ответа «wrong command»:  

error\nwrong command\n\n






Это всё можно запустит, проверить с помощью Vagrant

Воспользуемся Vagrant (инструмент для создания и управления виртуальными машинами). Перед его установкой необходимо установить Virtualbox, так как Vagrant – это инструмент управления виртуальными машинами, а не система виртуализации. https://www.vagrantup.com/docs/virtualbox/

Затем необходимо установить Vagrant. https://www.vagrantup.com/downloads.html 

После успешной установки нужно создать папку и в ней создать файл Vagrantfile. В Vagrantfile нужно скопировать:


$script = <<SCRIPT
    yum update
    yum -y install tcpdump nc telnet
SCRIPT

Vagrant.configure("2") do |config|
  config.vm.box = "centos/7"

  config.vm.provision "shell", inline: $script
end


Затем выполнить внутри папки:

>>> vagrant up
>>> vagrant ssh

Поздравляю, Вы внутри виртуальной машины. Если у вас windows, то немного сложнее: https://www.sitepoint.com/getting-started-vagrant-windows/


Открываем 3 терминала, заходим во внутрь виртуальной машины в каждом терминале (vagrant ssh). 

В первом терминале запустим Pythonи, запустим сервер:

>>> import server
>>> server.run_server('127.0.0.1', '8888')

Во втором терминале: 
>>> telnet 127.0.0.1 8888





